defaults: &defaults
  indices: [courts, judges, hearings, decrees, decree_pages, proceedings]

  per_page: 20

  index:
    number_of_shards: 1
    number_of_replicas: 1

    analysis:
      filter:
        stop_sk:
          type: stop
          stopwords: [a, aby, aj, ak, ako, ale, alebo, and, ani, áno, asi, až,
          bez, bude, budem, budeš, budeme, budete, budú, by, bol, bola, boli,
          bolo, byť, cez, čo, či, ďalší, ďalšia, ďalšie, dnes, do, ho, ešte,
          i, ja, je, jeho, jej, ich, iba, iné, iný, som, si, sme, sú, k, kam,
          každý, každá, každé, každí, kde, keď, kto, ktorá, ktoré, ktorou,
          ktorý, ktorí, ku, lebo, len, ma, mať, má, máte, medzi, mi, mna, mne,
          mnou, musieť, môcť, môj, môže, my, na, nad, nám, náš, naši, nie,
          nech, než, nič, niektorý, nové, nový, nová, nové, noví, o, od, odo,
          on, ona, ono, oni, ony, po, pod, podľa, pokiaľ, potom, práve, pre,
          prečo, preto, pretože, prvý, prvá, prvé, prví, pred, predo, pri,
          pýta, s, sa, so, si, svoje, svoj, svojich, svojím, svojími, ta, tak,
          takže, táto, teda, ten, tento, tieto, tým, týmto, tiež, to, toto,
          toho, tohoto, tom, tomto, tomuto, toto, tu, tú, túto, tvoj, ty,
          tvojími, už, v, vám, váš, vaše, vo, viac, však, všetok, vy, z, za,
          zo, že]

      analyzer:
        text_analyzer:
          type: custom
          tokenizer: standard
          filter: [asciifolding, lowercase, trim, stop_sk]

        normalizer:
          type: custom
          tokenizer: keyword
          filter: [asciifolding, lowercase, trim, stop_sk]

  script:
    suggest:
      name: suggest_matcher
      script: '
        import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilter;

        analyze = def (str) {
          size   = str.length();
          result = new char[size];

          ASCIIFoldingFilter.foldToASCII(str.toCharArray(), 0, result, 0, size);

          return new String(result).toLowerCase();
        };

        tokenize = def (str) {
          return str.split("\\s+");
        };

        value   = analyze(term);
        queries = tokenize(analyze(query));

        foreach(q : queries) {
          if (!value.contains(q)) {
            return null;
          }
        }

        return term;
        '

development:
  <<: *defaults

test:
  <<: *defaults

staging:
  <<: *defaults

production:
  <<: *defaults
